\chapter{Environment}\label{chapter:environment}
Before the state of the art technologies are implemented, which were presented in the last chapter. Describing the hardware and software for comparison provides a foundation for this thesis, since \gls{vr}, as well as real-time streaming, are still challenging for modern hardware,

\section{Hardware}\label{section:hardware}
Not many state-of-the-art head-mounted display with integrated eye-tracking exits. These are namely the HTC VIVE Pro Eye (see \autoref{fig:htcviveproeye}) or VRgineers’ XTAL \parencite{XTAL2020}. The first one has existing plugins for game engines and is widely available, and it is presented in \autoref{chapter:implementation}. In contrast, the XTAL has some more features like automatic eye calibration, but the software was not correctly functioning at the time of this project. Thus, the Pro Eye is used for the development of this project.
\par
For a network, usually two computers are necessary, but only one with the required hardware was available. Intel Realsense cameras are connected to a computer, acting as the server, which also performs the encoding of the streams. Efficient encoding is a matter of hardware as pure software encoding is much slower than the hardware-supported equivalents. There are two possibilities to encode on hardware: separated specialised hardware encoders and graphic cards. The first option receives a video input signal, encodes it and transmits it to the desired destination. It is mostly specialised on one codec which does not allow using multiple codecs such as the Matrox's H.264 encoders \parencite{Matrox2020}. The other option is to use graphic cards that are capable of encoding and decoding multiple codecs. Nevertheless, as the encoding is less critical for manufacturers than decoding, only the newest codes can be decoded and not encoded like the AV1 \parencite{AO2020}, which has had no consumer hardware implementation two years after its development. There is also a difference between the manufacturers as their implementation is also a factor. Currently, Nvidia’s solution called \gls{nvenc} is the fastest in the graphic cards segment, which is proven by multiple tests like references done by the streaming software OBS \parencite{OBS2020} and by self-comparison of an available AMD 5700XT and Nvidia 2080Ti. The last one was selected for further development. To serve the \gls{gpu} with data, the AMD Ryzen 3900X was used as this \gls{cpu} offers many core capabilities.

\section{Software}\label{section:software}
As previously mentioned, HTC offers \glspl{sdk} for multiple game engines like Unity3D \parencite{Unity2020} and the Unreal Engine \parencite{Unreal2020} to use display footage and to track the eyes. Since both engines are powerful enough and capable of displaying a stream in \gls{vr}, there is no difference between them in this case. Unity3D was selected for personal preferences, and the version 2019.4 was used.
\par
Many streaming solutions exist that have a wide range of codecs implemented that are open source or professional solutions. As all of them include more or less the same codecs based more or less on the same implementation, and the availability of \gls{sdk} for the used software languages is essential as a C\# implementation is necessary for Unity3D. Thus, the open-source solutions FFmpeg and VLC are candidates as both have a satisfactory working command-line interface as well as available public \glspl{sdk}. Moreover, the implementation is different for web real-time communication or WebRTC, which is not a codec but a communication protocol and is based on HTML5 and JavaScript. As this is a protocol mostly made for real-time communication, it was added to the list of possible candidates. The results of the speed comparisons between the different codecs and WebRTC are in \autoref{chapter:implementation}.
\par
For the image manipulation at the server-side, i.e. resizing and cropping the python implementation of OpenCV is used because OpenCV contains \gls{gpu} optimimized algorithms. OpenCV is also used for catching the video stream from the camera and splitting the vidoe into single images.
